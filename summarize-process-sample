#!/usr/bin/php
<?php

$warnings = [];
$threads = [];
$currentThread = '';
while (($line = fgets(STDIN)) !== false) {
  if (strstr($line, 'Dispatch Thread Soft Limit Reached'))
    $warnings[] = $line;

  if ($line === "Call graph:\n") {
    while (($line = fgets(STDIN)) !== false) {
      if ($line === "\n")
        break;

      // Find the beginning of each thread's stackframes.
      if (preg_match('/^\s{4}(\d+) (Thread_(\d+|<multiple>)((: |   )(.*))?)\n$/', $line, $matches))
        $currentThread = $matches[2];
      else
        $threads[$currentThread][] = substr(rtrim($line), 6);
    }
    break;
  }
}

print 'Sampled ' . count($threads) . " threads.\n";

if (count($warnings))
  print "\nWarnings:\n\t" . implode("\t", $warnings);

// Cull system/thread-startup noise.
$fluff = [
  'start_wqthread',
  '_pthread_wqthread',
  '_dispatch_worker_thread2',
  '_dispatch_root_queue_drain',
  '_dispatch_queue_override_invoke',
  '_dispatch_client_callout',
  '_dispatch_call_block_and_release',
  '_dispatch_async_redirect_invoke',
  '_dispatch_continuation_pop',
  '_dispatch_lane_barrier_sync_invoke_and_complete',
  '_dispatch_sema4_wait',
  'thread_start',
  '_pthread_start',
  '_pthread_body',
  '__psynch_cvwait',
  'glcDebugListener',
  'mach_msg_trap',
  'CFRunLoopRunSpecific',
  '__CFRunLoopRun',
  '__CFRunLoopDoSource1',
  '__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__',
  '_NSEventThread',
  '__CFRunLoopServiceMachPort',
  '-\[NSApplication\(NSEvent\) _nextEventMatchingEventMask',
  'AEProcessAppleEvent',
  'aeProcessAppleEvent',
  'dispatchEventAndSendReply',
  'aeDispatchAppleEvent',
  '_NSAppleEventManagerGenericHandler',
  '-\[NSAppleEventManager dispatchRawAppleEvent',
  '-\[NSApplication\(NSAppleEventHandling\) _handleCoreEvent:withReplyEvent:',
  '.*-\[NSApplication\(NSAppleEventHandling\) _handleAEOpenDocumentsForURLs',
  '-\[NSApplication\(NSAppleEventHandling\) _openURLs:withCompletionHandler:',
  'withWindowOrderingObserverHeuristic',
  'start',
  '_DPSNextEvent',
  '_BlockUntilNextEventMatchingListInModeWithFilter',
  'ReceiveNextEventCommon',
  '__CFRunLoopDoObservers',
  'semaphore_wait_trap',
  '__workq_kernreturn',
  '_dispatch_workloop_worker_thread',
  '_dispatch_lane_invoke',
  '_dispatch_lane_serial_drain',
  '_dispatch_source_invoke',
  '_dispatch_event_loop_wait_for_ownership',
  '_dispatch_ulock_wait',
  '__ulock_wait',
  '__DISPATCH_WAIT_FOR_QUEUE__',
  'CVDisplayLink::runIOThread',
  'CVDisplayLink::waitUntil',
  'QGuiApplicationPrivate',
  'QCoreApplication::notifyInternal2',
  'QApplicationPrivate',
];
foreach ($threads as &$thread)
  foreach ($thread as $key => $stackframe)
    foreach ($fluff as $func)
      if (preg_match("/^[\s!|:+]*\d+ $func/", $stackframe))
        unset($thread[$key]);

// Group threads by functions in their callstack (ignoring thread name, library, offset, and address).
$uniqueThreads = [];
foreach ($threads as $threadName => $thread) {
  $functions = [];
  foreach ($thread as $key => $stackframe)
    if (preg_match("/^[\s!]*\d+ (.*)  \(in .*\) \+ \d+/", $stackframe, $matches))
      $functions[] = $matches[1];
  $threadHash = implode(';', $functions);
  if (isset($uniqueThreads[$threadHash]))
    ++$uniqueThreads[$threadHash][0];
  else
    $uniqueThreads[$threadHash] = [
      1,
      $threadName,
      $thread,
    ];
}
usort($uniqueThreads, function ($a, $b) { return -($a[0] <=> $b[0]); });

print "\n";
print "Stack traces with similar threads grouped:\n";
foreach ($uniqueThreads as $uniqueThread) {
  printf("%5d x \033[36m%s\033[0m\n", $uniqueThread[0], $uniqueThread[1]);
  foreach ($uniqueThread[2] as $stackframe)
    print "            $stackframe\n";
}
